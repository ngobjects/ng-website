# State of the project

For quite a while (as in, for over a decade) I've been thinking about the future of my WebObjects-based software. While I love WO, it's now been obsolete and unmaintained for 15 years and as technology evolves, patching it through Project Wonder can only keep it going for so long. And it isn't really fun.

So, over the past couple of years I've been working on a side project to create something to use as my WO replacement, but based on the WO APIs. Although it's heavily based on WO, it's a total "white room implementation" done only through knowledge of WO and with some help from the Project Wonder sources. And the template parser is really just Project Wonder's `WOOgnl` parser (copied after asking Mike Schrag nicely). And I shamelessly ripped off `WOLifeBeatThread` since I suck at socket programming.

Amazingly enough, this thing is starting to work! It's been fun and even if I don't consider it "ready" I've started using it in some of my own projects — after all "dogfooding" is an essential part of making something nice. But, it's not "finished" and below are some (very random) thoughts about the state of parts of the framework and what needs work over the next few months. It's not a full list. If you look for FIXMEs and CHECKMEs in the sources, you'll find plenty. Oh boy, there are _plenty_. But the remaining issues are *design issues*. The framework is proven to "work" but is very much still in the design stage.

My plan is to replace WO in all of my software with this framework. Even at this early stage, it already feels really nice to be able to fix and improve one's stack without having to resort to hacks and patches in Project Wonder. I'm aiming for _mid to late 2024_ to start porting business critical projects and client projects, and really tell other people about this. In the meanwhile, I'd love if interested people try this out and give ideas and feedback.

## Why the changes?

I sometimes ask myself if it's a mistake to make changes from WO. Perhaps I should just be cloning WO as much as possible, it's easier and makes it simpler to port existing WO applications.

But I do believe that a better framework is worth adding a few hours to an applications' porting process. While WO is awesome, Java has evolved and we've learned a thing or two in the last 20 years.

## Why I'm taking so long?

As should be apparent, my mindset for this project is more "get it right" than "hurry up". I've used WO for 20 years so spending a couple of years on good design now won't hurt too much.

In the end, I want something that feels like WO when I first experienced it: Delightful, fun, well designed, easy to use, intuitive and just plain awesome. I don't feel like these terms apply to a lot of today's web development stacks. I want something so fun and intuitive that my 10, 11 and 13 year old kids can use it and love it.

## So, to start somewhere: Project structure

An `ng-objects` application currently just uses the standard maven layout for projects. I'm still not sure if this will be the final project structure, but it's convenient to use at the moment since it means we need no custom logic to locate resources or perform a build. Everything's on the classpath.

## Building an app

An ng-objects application can be built for deployment using the [vermilingua-maven-plugin](https://github.com/undur/vermilingua-maven-plugin) which is really just a plain maven (as in, no ant) version of `wolifecycle-maven-plugin`.

You just need to add a `build.properties` file to your project's root with `principalClass=[your app's main class]`. An application built like this looks pretty much the same as a WO application and can be deployed to a WO environment and managed by wotaskd/JavaMonitor.

This is familiar and convenient for WO developers. However, I'd like to look into improving the build process and, for example, explore using `jpackage` which can package applications and bundle a custom JVM.

## The global NGApplication object

WO has a global WOApplication singleton accessed via the static method `application()` . `ng-objects` currently has this too, but having a global application object has problems, most importantly it means you can only have _one_ `NGApplication` instance available at a time. This can be a problem, not least during testing, where you might want to construct multiple application objects with different properties/configuration.

So. The goal is to get rid of the global NGApplication object. The sole reason I haven't done so already is that I haven't entirely decided *how*. `NGApplication`, like `WOApplication` is very central to the framework and functions in a way a little like a factory/injector with all it's create...() methods while also handling a lot of configuration etc. But I'm still not sure we want to use actual dependency injection.

Anyway. The point is that the global `NGApplication.application()` will probably go at some point, it's just a question of when and how.

## Configuration (NGProperties)

There are no static methods to fetch property values like on NSProperties/ERXProperties, instead an `NGApplication` has an `NGProperties` object containing it's configuration accessed through `NGApplication.properties()`. This is due to the previously mentioned goal of making `NGApplication` standalone, i.e. being able to run multiple NGApplications with different configurations within one JVM.

There are a few improvements to the property mechanism which I'll detail better later. Configuration is a really important core feature and just needs to be awesome.

## Modes (such as "Development mode")

Having modes like the "Development mode" which `ERXApplication` provides with `isDevelopmentMode()` is nice. So we have that method and it's value is currently simplistically based on the `-WOMonitorEnabled` property.

I'd still like to improve on this. Software tends to have multiple modes  (Production/Testing/Local etc) and they will differ between products/environments. Configuring "modes" should be thought about as a whole and though I haven't thought this through we might end up with something along the lines of `application().mode().is( Mode.Development )`.

## Logging / Monitoring

Logging is currently handled very simplistically using `slf4j-api`. Like WO, `ng-objects` writes logs to whatever is specified by `-WOOutputPath` or `System.out` if no output path is set.

We currently don't have any other monitoring, but that's something we want to look into as it's hugely useful for web applications. We'll probably also want to revisit the use of `slf4j` and either use Java's own logger and/or create our own `NSLog ` style abstraction, allowing applications to plug into JFR or other monitoring/event recording tools.

## Routing

WO has the concept of "request handlers" that we've expanded on a bit and call "Routing". It's still very primitive and we currently only have:

* Exact Routes: `addRoute( "/some/page", someHandler  )`
* "Begins with" routes: `addRoute( "/wo/*", someHandler )` (note the wildcard)

In other words, routing needs some love to become good. Frameworks like Spark, Javalin and Helidon have nice routing concepts and syntaxes I think we can learn from. This is something that's worth getting _right_ from the start since it would be irritating to wreck people's routes with syntax changes early on.

## Direct Actions

In a way, routing replaces Direct Actions. There's a rudimentary implementation of Direct Actions in ng-objects, mostly because DAs are easy to implement and for compatibility with older software. But I'm still not sure these will be in the final product. Exposing class and method names in URLs feels iffy, writing an actual route will always be the nicer way to create static URLs.

## Template parsing

The template parser in ng-objects began as a pure copy/paste rip-off of the WOOgnl-parser in Project Wonder, although it's seen some changes and updates through the years I've been working on this. Like WOOgnl, it handles both single file templates (HTML-files using inline bindings) or the good ol' `.wo` html/wod folder templates. Oh, and there's no actual OGNL. If you need logic, write it in Java. 

If there's anything I'd like to improve in this area, it's error reporting. Specifically, I'd like to parse an erraneous template in it's entirety and report all it's errors at the same time instead of stopping parsing immediately when an error is encountered and report the single error. We also need to show the template's source and highlight the errors (in the same way our exception page does with Java code).

## Template rendering

Template generation/rendering was definitely the hardest and most fun challenge of the project. And I think we can make it better.

I'd like to improve error reporting. We all know and love WO's meter long rendering stack traces that *really* should show more context so we actually know where errors originate. Unfortunately, our stack traces currently look very similar to WO's and I'm still considering ways to improve this. Ideas welcome!

With the advent of virtual threads in JDK 21, I'm also a little excited about exploring multi-threaded rendering. In theory, each component/element could be rendered in it's own thread and the results assembled at the end of the R-R loop. This means *automatically multi-threaded web applications*, which I don't only think is cool, it's something I want. It might even be enough to just apply threading to the pushing/pulling of binding values, since that's usually the stage where processor-intensive method invocations happen.

However, threaded rendering would require some API changes since `NGContext` is almost criminally stateful/mutable and thus not very threading-friendly.

(BTW, at this point — are you seeing how much fun this is? To no longer be bound by a framework we can't change, so we can do anything we want?)

## Compiled templates?

A final thought on templates: While our bindings/associations currently work like WO's and use KVC/reflection to resolve keypaths to fields and methods, we might want to consider looking into "compiled templates", i.e. compile the templates to java classes before deployment.

The reason I'm considering this is that GraalVM has been picking up pace lately and it does not agree with reflection.

This is something I'd consider cool, but it's not a priority.

## Namespaces

WO has:

- a "global namespace" for dynamic elements/components (classes and templates) — oh, and Direct Action classes.
- `app` for application resources and
- `[frameworkName]` for frameworks.

We currently follow more or less the same pattern, but I think the "global namespace" needs a little thinking. It really shouldn't exist.

## Plugins/Modules ("Frameworks" in WO terms)

Plugins will have to be a thing, "plugin" basically being what a "framework" is in WO; just something that provides code, resources and configuration.

There's currently a very simplistic implementation of something called `NGPlugin` at the moment but like with namespaces, a "final design" has not yet been decided on.

## Development environment (WOLips?)

Since the templating language in ng-object is (still) the same as in WO, the WOLips component editor actually works fine for working with NGComponents.

The choice I'm now facing is:

* Should I integrate ng-objects support into WOLips?
* Or should I just write an entirely new plugin?
* Or clone WOLips, remove what we don't use and clean up what we _do_ use?

I'm currently leaning towards the third option. But there's also the fourth option of looking into support for other IDEs like IDEA or Visual Studio Code, which would probably be a good option to appeal to people more "hip" and "cool" than me.

## Integration with a WO deployment environment

ng-objects applications inegrate fine in a WO deployed environment and can be run and monitored by wotaskd/JavaMonitor.

## Localization

We currently offer no support for localization. In fact I'm still thinking about if we actually _should_. I used WO's localization facilities at the very beginning almost two decades ago, but just stopped using it and implemented my own solutions where neccessary. But, as always, hearing voices on this matter from people that use WO's localization successfully today would be nice. Perhaps the improvements in Wonder are so vast that it's something that's worth taking a look at.

## Formatters

I'm really going into details here, but… In the WO world, WOString and WOTextField accept formatters and format patterns for numbers and dates. I'm still thinking about how best to implement this in ng-objects. I'm a bigger fan of formatting in code rather than using the pattern strings but one way might to be to accept a formatter binding and while we could accept a java.text.Formatter, we might prefer a "formatter wrapper class" that could allow for more types of formatters (at last java.time.format.DateTimeFormatter which is kind of required these days).

## The webserver adaptor

Like WO, `ng-objects` uses "adaptors" which serve as the framework's web server.

Our only HTTP adaptor is currently a servlet served by Jetty and provided as a separate module. And it's built in a somewhat modular way. `ng-objects` doesn't depend on Jetty or Servlet APIs in any way. And since the adaptor is really just a plain servlet (with no dependencies on Jetty) it could be served up by any servlet container.

I'd love to write an HTTP adaptor from scratch at some point, but at the moment, the Jetty adaptor just works really well, HTTP is messy, and writing an adaptor is not a priority. About the only irritating thing about Jetty is that it's an additional dependency.

## No Foundation

We don't implement any foundation classes. Java has a fine collection of base classes.

## That being said - KeyValueCoding

OK, so I lied a little. In WO, KeyValueCoding is a part of foundation and I've implemented it to resolve keyPaths in component templates. The implementation is rudimentary compared to WO but still improves on it in some ways, for example it works with internal classes like `java.util.ImmutableCollections$ListN` generated by, for example `List.of()`. There's a lot of work left in cleanup and some work left in type bridging (where, for example, a `String` value gets assigned to a `Double` and some automagical conversions happen).

Our KVC implementation does not support `@` operators, like appear in `"$products.@sum.price"` or `"$employees.@sortAsc.name"`). I'm hesitant about whether to implement operators or not, they feel like logic is leaking into templating and I'm a firm believer in logic and templating being different things. Templates should be as stupid as possible. But operators can still be convenient, not least during prototyping (which is one of the areas where WO just shines). So it's still something to think about.

## WebSockets

Not there yet, but something we definitely need to add support for. Mostly an API design issue.

## HTTP/2 and HTTP/3

HTTP/2 and /3 are not supported yet but that's something we will want to add. The first step is to get to know the protocols so I can start thinking about what they mean with regard to APIs. And we'd have to ensure that the HTTP APIs are designed in such a way that changing versions doesn't get in the way of work. You basically want to be able to flip a switch without making code modifications to work with the new current protocols transparently, while also getting access to the protocols' improvements.


## Basic HTTP APIs

While WOResponse is nice, I'm wondering if it might be a good idea to replace the single class with an `NGResponse` interface and multiple implementing response classes (streaming, string, data etc.). I haven't touched on this aspect yet since I think that once we start looking into WebSockets and new HTTP versions, they will affect the API design.

## Ajax

Work on Ajax-framework style request handling is being experimented with in the `ajax-experiments` branch of the main repo. Introducing Ajax in pretty much the same way that `Ajax.framework` does in WO will not be a technical challenge, but is something of a design challenge. This is an important area that I think we can improve on.

## Persistent sessions

Yeah.

## Component actions

Yes, we have component actions. They are really the largest reason why --WO-- exists. But we have vastly simplified the request handling process. For each phase of the R-R cycle, WO will go Application -> Session -> Component. I didn't really see a reason to follow this model, so 


## A note on parameter ordering

Some (very few) methods in the new APIs "switch argument order" from the order in WO's methods.

One of the relics of the WO APIs's Objective-C origins is the somewhat "untraditional" ordering of parameters in methods that take a "key" and a "value" when setting something. `NGKeyValueCoding` is an example, but in that case we still maintain the same order as `NSKeyValueCoding`, but that's mostly because the method names there helpfully let you know what you're doing (`takeValueForKey` is fine as is, although I _have_ considered adding second methods to the interfaces with a different names and switched up parameters).

But in some places, this kind of doesn't work. The most notable one (because it may cause errors) is `WOMessage.setHeader( value, headerName )`. This parameter order will absolutely confuse 99% of the developer world that hasn't used WO, so `NGMessage` switches up and defines `setHeader( headerName, value )`. I'm still thinking about the best approach here though, since both parameters are plain strings, meaning lazily copy/pasted WO code will silently do the wrong thing (by which even I have been burnt). Food for thought.

## Current code base testing status

There are still veeery few unit tests present, primarily because the software's design was (and still is) very fluid. I'm mentioning this just to make a note that there will be excellent tests present in the software later :).

## Java Modularization

ng-objects is currently not "modular" in the java sense, mostly since the design is still evolving, making it a little bothersome to keep `module-info.java` up to date for every refactoring.

However, modularization is definitely something we want to perform. Being able to generate customized JVMs using `jpackage` will be very nice. This won't happen until the design stabilizes a little though.

## A generic note on nullity

One reason I've not been hurrying to create a final product is that the Java team is hard at work finding a solution to Java's "null problem". ng-objects's APIs are designed to make it easy to port WO applications to it, it uses null heavily just as WO does. But as we know, nulls are a source of a whole lot of problems. I'm not a big fan of `Optional` because it just isn't really that great. So, I'm waiting a little to see what the Java team will do here, and then implement it.

## Regarding EOF

This framework does not give any thought to databases. It's a plain web framework.

That being said, there's nothing that prevents EOF code from being used with it. I use `Cayenne` instead which is very EOF-like and I love it. Alongside `ng-objects` I've written a companion framework called `ng-hafnium` which is a somewhat CRUDdy-framework based on something I've used in my WO projects for years which does some Direct-To-Webby stuff. I kind of love it so that project will move forward.

But I just wanted to mention EOF, because it's a huge part of most people's applications and business logic. I can't recommend Cayenne enough. The project is nice, the guys working on the project are helpful and awesome and it's just all around awesome.

## Name and Branding

`ng-objects` isn't really catchy and I don't really know why it's called that. So... Help!



# Thanks for coming to my TED-talk.

So, that's it for now. I told you this would be a long and very random post. As you can see, there's a whole lot happening in my head regarding this project. I'm spending quite a bit of time working onit, and I'd absolutely love your ideas and thoughts on this project.