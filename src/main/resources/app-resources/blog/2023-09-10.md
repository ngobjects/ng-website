# State of the project

For quite a while (as in, for over a decade) I've been thinking about the future of my WebObjects software. While I love WO, it's now been obsolete/unmaintained for 15 years and as technology evolves, patching it through Project Wonder can only keep it going for so long.

So, over the past couple of years, I've been working on a side project to create something to use as my WO replacement, working from the WO APIs. It's a complete "white room implementation" done through experimentation and knowledge of WO, and some help from the Project Wonder sources. Well, and the template parser is Project Wonder's `WOOgnl` (plain copied after asking Mike nicely). And I shamelessly ripped off `WOLifeBeatThread` since I suck at socket programming.

But amazingly enough, this thing is starting to work. It's been fun and even if I don't consider it "ready" I've already started using it in some of my own projects — after all "dogfooding" is an essential part of making something really nice. But, it's definitely not "finished" so below are some (very random) thoughts about the state of parts of the framework and what needs work over the next few months. It's not a full list. If you look for FIXMEs and CHECKMEs in the sources, you'll find plenty. Oh boy, there are _plenty_. But those issues are really design issues. The framework already "works", but is still very much in the design stage.

My plan is to replace WO in all of my software with this framework. Even at this early stage, it already feels really nice to be able to fix and improve one's stack without having to resort to hacks and patches in Project Wonder. I'm aiming for _mid to late 2024_ to start porting customer projects and business critical projects and start _really_ telling other people about this. In the meanwhile, I'd love if interested people test it and give feedback on the design.

## Why take so long?

As should be apparent, my mindset for this project is more "get it right" than "hurry up". I've used WO for 20 years so spending a couple of years on good design now won't hurt too much.

In the end, I want something that feels like WO when I first experienced it: Delightful, surprisingly well designed, easy to use, intuitive and just plain awesome. I don't feel like that applies to a lot of today's web development stacks. I want something so intuitive that my 10, 11 and 13 year old kids can start using it and love it.

## Why make changes?

During the work on this project I've sometimes asked myself if it's a mistake to make changes from WO. Perhaps I should just clone WO as much as possible, it's really easier to do and makes it simpler to port existing WO applications.

But I do believe that adding a few hours to applications' porting processes will be worth it if we end up with a better framework. While WO is awesome, Java has evolved and we've learned a thing or two in the last 20 years.

## Project structure

An `ng-objects` application currently just uses/expected the standard maven layout for projects. I'm not sure this will be the final project structure, but it's convenient to use during development since we need no custom logic to locate resources or perform a build. Everything's on the classpath.

## Building an app

A standalone ng-objects application can be built using the [vermilingua-maven-plugin](https://github.com/undur/vermilingua-maven-plugin) which is really just a plain maven (as in, no ant) version of `wolifecycle-maven-plugin`.

Only thing you need to add is a `build.properties` file in your project's root with `principalClass=[your app's main class]`. An ng-objects application built like this looks pretty much the same as a WO application, can be deployed to a WO environment and managed by wotaskd/JavaMonitor.

This is very familiar and convenient for existing WO developers. However, in the next months I'd like to look into this further, for example explore the use of `jpackage` which can build/package applications bundled with a custom JVM.

## The global NGApplication object

WO has a global WOApplication singleton accessed via the static method `application()` on NGApplication. `ng-objects` currently does too but having a global NGApplication object has problems, most importantly it means you can only have _one_ `NGApplication` instance available at each time. This can be a problem, not least during testing, where you might want to construct a few application objects with different properties/configuration.

So. The goal is to get rid of the global NGApplication object. The sole reason I haven't done it already is because I haven't entirely decided how it should be replaced. `NGApplication`, like `WOApplication` _is_ very central and functions in a way a little like an injector with all it's create...() methods, handles a lot of global configuration etc. But I'm not sure we want to use dependency injection.

Anyway. `NGApplication.application()` will probably go at some point, it's just a question of when and how.

## Configuration (NGProperties)

There are no static methods to fetch property values like on NSProperties or ERXProperties, each `NGApplication` has an `NGProperties` object with it's configuration. This is due to the previously mentioned goal of making `NGApplication` standalone, i.e. being able to run multiple NGApplications within one JVM. So - properties are always accessed through the instance method `NGApplication.properties()`.

There's also some improvements to properties, i.e. properties are not just a key/value map. Properties know where they originate from and where they've been set [see video]. Properties are designed to be more "verbose.

## Modes (such as "Development mode")

Having modes like the "Development mode" which `ERXApplication` provides with `isDevelopmentMode()` is indeed nice for some things. So we have that method (and it's return value is currently based on the `-WOMonitorEnabled` property). But I'm not a fan of this because software usually has more modes  (Production/Testing/Local etc.) and these can be different between products. Configuring these "modes" is something that should be thought about as a whole. I haven't quite designed this in my head though, but we might end up with something like `application().mode().is( Mode.Development )` or something like that. Yet another thing to think about.

## Logging / Monitoring

Logging is currently handled using `slf4j-api` and like WO, `ng-objects` will output the application's logs to whatever is specified by `-WOOutputPath` or `System.out` if no output path is set.

We don't currently provide any other "monitoring", but that's something we want to consider since monitoring is exceedingly useful for web applications. We might also want to revisit the use of `slf4j` and either use Java's own logger or create our own `NSLogging ` style logging module, allowing us to plug into JFR or other monitoring/event recording tools.

## Routing

While WO has the concept of "request handlers" we've expanded on that a bit and we call it "Routing". It's still very simple and we currently only have:

* Exact Routes `(addRoute( "/some/page", someHandler  )`
* "Begins with" routes `addRoute( "/wo/*", someHandler )` (note the wildcard)

In other words, routing needs some work and love to become good. Frameworks like Spark, Javalin and Helidon have some pretty nice routing concepts I think we can learn from. This is one piece that's worth getting _right_ from the start once we get going. It would be irritating to wreck people's routes with syntax changes.

## Direct Actions

In a way the routing mechanism kind of replaces Direct Actions. There _is_ a rudimentary implementation of Direct Actions present (DAs are rather simple and thus easy to implement), mostly for compatibility with older software, but I'm still considering if we really want include these in the future. Exposing class and method names feels a little iffy and a route will always be a nicer way to create static reusable URLs. Something to think about.

## Template parsing

The template parser in ng-objects is mostly a pure copy/paste rip-off of the WOOgnl-parser in Project Wonder, with some slight changes and updates through the years I've been working on it (and there's no actual OGNL). Like WOOgnl, it handles both single file templates (HTML-files using inline bindings only) or the good ol' `.wo` html/wod folder templates.

If there's anything I'd like to improve, it's error reporting. Specifically, I'd like a broken template (for example, referencing non-existent elements/components) to be parsed in one go so errors could all be reported in one go rather than one at a time.

## Template rendering

Template rendering was the largest and  most fun challenge of the project. I'd like to improve error reporting here. We're probably all familiar with WO's kilometer long stack traces that could really show some more context for each stack trace element. Also, viewing the template's source file and highlighting the error (in the same way our exception page does for Java code) would be pretty cool.

With the advent of Virtual threads in JDK 21, I'm also a little excited about exploring ways to make template rendering multi-threaded. It could even just apply to the pushing/pulling of binding values, since that's usually where most method invcations happen and are thus most processor intensive. But in theory, each component/element can absolutely do it's work inside it's own thread and then we can assemble everything at the end of the R-R loop. However, this might require some API changes, since `NGContext` is inherently stateful.

## Namespaces

Namespaces are not implemented since we're still thinking about the proper way to do it and it's critical to "get right" early on.. WO currently has:

- a "global namespace" for dynamic elements/components (classes and templates) — oh, and Direct Action classes.
- `app` for application resources and
- `[frameworkName]` for frameworks.

## Plugins/Modules ("Frameworks")

Plugins will have to be a thing, "plugin" basically being what a "framework" is in WO; just something that provides code, resources and configuration.

There's currently a very simplistic implementation of something called `NGPlugin` at the moment but like with namespaces, a "final design" has not yet been decided on.

## Development environment (WOLips?)

Since the templating language in ng-object is (still) the same as in WO, WOLips actually provides some niceties when working with it, like autocompleting in the template editor from keypaths in the associated java files.

* Integrate ng-objects support into WOLips
* Write an entirely new plugin
* Just clone WOLips and start removing what we currently don't use and clean up what we _do_ use.

Currently I'm leaning towards the third option. But then there's a fourth option of looking into support for IDEA or Visual Studio Code, both of which are probably good options to appeal to people more "hip" and "cool" than me.

## Integration with a WO deployment environment

## Localization

We currently offer no support for localization. In fact I'm still thinking about if we actually _should_. I used WO's localization facilities at the very beginning almost two decades ago, but just stopped using it and implemented my own solutions where neccessary. But, as always, hearing voices on this matter from people that use WO's localization successfully today would be nice. Perhaps the improvements in Wonder are so vast that it's something that's worth taking a look at.

## Formatters

So… In WO world, WOString and WOTextField accept formatters and format patterns for numbers and dates. I'm still thinking about how best to implement this in ng-object. I'm a bigger fan of formatting in code, rather than using  but one way might to be to accept a formatter binding and while we could accept a java.text.Formatter, we might prefer a "formatter wrapper class" that could allow for more types of formatters (at last java.time.format.DateTimeFormatter which is kind of required these days). And I'm not sure about dateFormat and numberFormat...

## The webserver adaptor

Like WO, `ng-objects` has a separate "adaptor" which serves as the framework's web server, the "gate to the outside HTTP world". Our main HTTP adaptor is currently implemented as a servlet served up by Jetty and provided as a separate module. And it's built in a somewhat modular way. `ng-objects` itself doesn't depend on Jetty APIs in any way and since the Jetty adaptor is really just a servlet (with no dependencies on Jetty, just the servlet API) it could be served up by any servlet container.

I'd love to include my own adaptor at some point, but it turns out that the Jetty adaptor works really well, HTTP can be messy, and writing our own adaptor is not a priority. About the only irritating thing about Jetty is that it's an additional dependency.

## No Foundation

We don't implement foundation. Java has a fine collection of base classes.

## That being said - KeyValueCoding

OK, so I lied a little. In WO, KeyValueCoding is a part of foundation and I've implemented it to resolve keyPaths in component templates. The implementation is rudimentary, but still improves on WO's `NSKeyValueCoding` in some ways, for example it works with internal classes like `java.util.ImmutableCollections$ListN` generated by, for example `List.of()`. There's a lot of work left in cleanup and some work left in type bridging (where, for example, a `String` value gets assigned to a `Double` and some automagical conversions happen).

Our KVC implementation does not (yet?) support `@` operators, like appear in `"$products.@sum.price"` or `"$employees.@sortAsc.name"`). I'm still a little hesitant about whether to actually implement these or not, they feel like logic is leaking into templating and I'm a firm believer in that logic and templating are different things and and templates should be as stupid as possible. But operators can still be convenient, not least during prototyping (which is one of the areas where WO just shines). So it's still something to think about.

## Resource handling

## WebSockets

## HTTP/2 and HTTP/3

HTTP/2 and /3 are not supported yet but that's something we definitely want to add. First I want to get to know the protocols so I can start thinking about how their APIs would look insode `ng-objects`. And we'd have to ensure that the HTTP APIs are designed in such a way that changing versions doesn't get in the way of work. You basically just want to be able to flip a switch, and be working with the current protocols transparently, while also getting access to work with the protocols' improvements.


## HTTP APIs

While WOResponse is nice, I'm wondering if it might be a good idea to replace the single class with an `NGResponse` interface and multiple response types (streaming, string, data etc.). However, I have not touched on this aspect yet, since I think that once we start looking into WebSockets and new HTTP versions, that will affect the API design.

## Ajax

Ajax request handling has been experimented with in the `ajax-experiments` branch of the main repo. It does not look like introducing Ajax in pretty much the same way that `Ajax.framework` does in WO will not be a technical challenge, but I still consider it something of a design challenge. since this is an important area that we would improve on.

## Persistent sessions

## Component actions

Yes, we have component actions. They are really the largest reason why --WO-- exists. But we have vastly simplified the request handling process. For each phase of the R-R cycle, WO will go Application -> Session -> Component. I didn't really see a reason to follow this model, so 


## A note on parameter ordering

Some (very few) methods in the new APIs "switch argument order" from the order in WO's methods.

One of the relics of the WO APIs's Objective-C origins is the somewhat "untraditional" ordering of parameters in methods that take a "key" and a "value" when setting something. `NGKeyValueCoding` is an example, but in that case we still maintain the same order as `NSKeyValueCoding`, but that's mostly because the method names there helpfully let you know what you're doing (`takeValueForKey` is fine as is, although I _have_ considered adding second methods to the interfaces with a different names and switched up parameters).

But in some places, this kind of doesn't work. The most notable one (because it may cause errors) is `WOMessage.setHeader( value, headerName )`. This parameter order will absolutely confuse 99% of the developer world that hasn't used WO, so `NGMessage` switches up and defines `setHeader( headerName, value )`. I'm still thinking about the best approach here though, since both parameters are plain strings, meaning lazily copy/pasted WO code will silently do the wrong thing (by which even I have been burnt). Food for thought.

## Current code base testing status

There are still veeery few unit tests present, primarily because the software's design was (and still is) very fluid. I'm mentioning this just to make a note that there will be excellent tests present in the software later :).

## Java Modularization

ng-objects is currently not "modular" in the java sense, mostly since the design is still evolving, making it a little bothersome to keep `module-info.java` up to date for every refactoring.

However, modularization is definitely something we want to perform. Being able to generate customized JVMs using `jpackage` will be very nice. This won't happen until the design stabilizes a little though.

## A generic note on nullity

One reason I've not been hurrying to create a final product is that the Java team has been hard at work finding a solution to Java's "null problem". ng-objects utilizes null heavily in the same way as WO does, but as we all know, nulls can be sources of problems. I'm not a big fan of `Optional` because it just isn't really great. So, I'm waiting a little to see what the Java team will do here, and then implement it.

## Regarding EOF

To be clear, this framework does not touch on databases (meaning no EOF). It's a web framework.

This being said - there's nothing that prevents EOF code from being used with it (although I'd honestly consider not doing that). I use `Cayenne` which is very EOF-like and I love it. Alongside `ng-objects` I've written a companion called `ng-hafnium` which is the start of a DB-framework similar to something I've used in my WO projects for years and does some Direct-to-Web like stuff on the back end. Who knows where that might go.

In other words: ORMs and databases are a different story. But `ng-objects` will, like WO, be a fine platform to base something nice like WO's D2W on if that's what you want.

## Name and Branding

`ng-objects` isn't really catchy, so I've long been thinking about